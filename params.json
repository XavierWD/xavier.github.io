{
  "name": "Xavier.GitHub",
  "tagline": "Quartz分布式任务调度",
  "body": "#Quartz\r\n\r\nQuartz中一个Job往往是一个任务业务逻辑的实现，Job并不知道何时被执行。那么执行一个Quartz Job的是一个Trigger实例。\r\n\r\n##Quartz Trigger\r\nquartz的trigger有三种\r\n\r\n1. org.quartz.SimpleTrigger\r\n2. org.quartz.CronTrigger\r\n3. org.quartz.NthIncludedDayTrigger\r\n\r\nSimpleTrigger 是用来执行一些简单的任务配置的。比如在指定的时间开始然后在一定的时间间隔之内重复执行一个Job\r\n\r\n##Quartz Job\r\n任务的实体\r\n\r\n##Quartz Thread\r\n> org.quartz.core.QuartzSchedulerThread\r\n主要执行获取，运行Job的线程。\r\n\r\n\r\n##Quartz的数据库表\r\n\r\n- BLOG_TRIGGERS   \r\n- Callendars  \r\n- Cron_Triggers 记录Cron的触发器\r\n- Fired_Triggers 记录处于触发中的触发器\r\n- Job_Details  记录任务的详细情况\r\n- Locks   锁。用于分布式的时候加锁\r\n- Paused_Trigger_GRPS  暂时没有研究\r\n- Scheduler_State   记录Scheduler实体\r\n- Simple_Triggers    Simple的触发器\r\n- Simprop_Triggers  \r\n- Triggers   触发器集合\r\n\r\n\r\n##Quartz Store\r\n\r\n>org.quartz.spi.JobStore\r\n\r\n两个实现类\r\n\r\norg.quartz.impl.jdbcjobstore.JobStoreTX //把Trigger，Job存放于数据库中，就算掉线也能再次执行未完成的任务\r\n\r\n\r\n##大致过程\r\n\r\n创建SchedulerFactoryBean\r\n\r\n使用StdSchedulerFactory创建一个SchedulerFactory实例\r\n\r\n\r\n\r\norg.quartz.impl.jdbcjobstore.StdRowLockSemaphore  加锁\r\n\r\nJobStoreSupport # schedulerStarted 对失败的任务进行处理\r\n\r\n##集群可以互斥原理\r\n\r\n在每次执行的时候，QuartzThread会先在table表中选出Trigger，然后在加锁的情况下，把要执行的任务的Trigger选择出状态为Waiting的Insert进Fired_Triggers表里面，这个动作称为获取 ACQUIRED。然后把Trigger的Status更改为ACQUIRED。这样放开锁之后，集群中别的机器也就拿不到这个Trigger了。\r\n\r\n其中这里Insert Fired_Trigger的时候有插入一个新的属性Instance_Name 这个属性是由Quartz通过主机名来生成的。所以在集群中，基本可以认为是唯一标示。\r\n\r\nJobStoreSupport .schedulerStarte。会从Scheduler里面获取没有完成任务的Scheduler，然后根据实例名，从FiredTrigger里面获取未完成的Trigger。然后在Triggers里面吧Acquire置为Waiting。然后执行线程继续获取到。\r\n其中是通过Scheduler_State这个表中的属性，因为每个多少秒，就会有任务去更新自己的Scheduler的最后检查时间，如果别的scheduler发现有的scheduler已经超时未来更新，就会判断它为已经失败的scheduler，然后就会接替它。\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}