<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Xavier.GitHub : Quartz分布式任务调度">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Xavier.GitHub</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/a328940026/xavier.github.io">View on GitHub</a>

          <h1 id="project_title">Xavier.GitHub</h1>
          <h2 id="project_tagline">Quartz分布式任务调度</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/a328940026/xavier.github.io/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/a328940026/xavier.github.io/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="quartz" class="anchor" href="#quartz" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quartz</h1>

<p>Quartz中一个Job往往是一个任务业务逻辑的实现，Job并不知道何时被执行。那么执行一个Quartz Job的是一个Trigger实例。</p>

<h2>
<a id="quartz-trigger" class="anchor" href="#quartz-trigger" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quartz Trigger</h2>

<p>quartz的trigger有三种</p>

<ol>
<li>org.quartz.SimpleTrigger</li>
<li>org.quartz.CronTrigger</li>
<li>org.quartz.NthIncludedDayTrigger</li>
</ol>

<p>SimpleTrigger 是用来执行一些简单的任务配置的。比如在指定的时间开始然后在一定的时间间隔之内重复执行一个Job</p>

<h2>
<a id="quartz-job" class="anchor" href="#quartz-job" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quartz Job</h2>

<p>任务的实体</p>

<h2>
<a id="quartz-thread" class="anchor" href="#quartz-thread" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quartz Thread</h2>

<blockquote>
<p>org.quartz.core.QuartzSchedulerThread
主要执行获取，运行Job的线程。</p>
</blockquote>

<h2>
<a id="quartz的数据库表" class="anchor" href="#quartz%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quartz的数据库表</h2>

<ul>
<li>BLOG_TRIGGERS<br>
</li>
<li>Callendars<br>
</li>
<li>Cron_Triggers 记录Cron的触发器</li>
<li>Fired_Triggers 记录处于触发中的触发器</li>
<li>Job_Details  记录任务的详细情况</li>
<li>Locks   锁。用于分布式的时候加锁</li>
<li>Paused_Trigger_GRPS  暂时没有研究</li>
<li>Scheduler_State   记录Scheduler实体</li>
<li>Simple_Triggers    Simple的触发器</li>
<li>Simprop_Triggers<br>
</li>
<li>Triggers   触发器集合</li>
</ul>

<h2>
<a id="quartz-store" class="anchor" href="#quartz-store" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quartz Store</h2>

<blockquote>
<p>org.quartz.spi.JobStore</p>
</blockquote>

<p>两个实现类</p>

<p>org.quartz.impl.jdbcjobstore.JobStoreTX //把Trigger，Job存放于数据库中，就算掉线也能再次执行未完成的任务</p>

<h2>
<a id="大致过程" class="anchor" href="#%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>大致过程</h2>

<p>创建SchedulerFactoryBean</p>

<p>使用StdSchedulerFactory创建一个SchedulerFactory实例</p>

<p>org.quartz.impl.jdbcjobstore.StdRowLockSemaphore  加锁</p>

<p>JobStoreSupport # schedulerStarted 对失败的任务进行处理</p>

<h2>
<a id="集群可以互斥原理" class="anchor" href="#%E9%9B%86%E7%BE%A4%E5%8F%AF%E4%BB%A5%E4%BA%92%E6%96%A5%E5%8E%9F%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>集群可以互斥原理</h2>

<p>在每次执行的时候，QuartzThread会先在table表中选出Trigger，然后在加锁的情况下，把要执行的任务的Trigger选择出状态为Waiting的Insert进Fired_Triggers表里面，这个动作称为获取 ACQUIRED。然后把Trigger的Status更改为ACQUIRED。这样放开锁之后，集群中别的机器也就拿不到这个Trigger了。</p>

<p>其中这里Insert Fired_Trigger的时候有插入一个新的属性Instance_Name 这个属性是由Quartz通过主机名来生成的。所以在集群中，基本可以认为是唯一标示。</p>

<p>JobStoreSupport .schedulerStarte。会从Scheduler里面获取没有完成任务的Scheduler，然后根据实例名，从FiredTrigger里面获取未完成的Trigger。然后在Triggers里面吧Acquire置为Waiting。然后执行线程继续获取到。
其中是通过Scheduler_State这个表中的属性，因为每个多少秒，就会有任务去更新自己的Scheduler的最后检查时间，如果别的scheduler发现有的scheduler已经超时未来更新，就会判断它为已经失败的scheduler，然后就会接替它。</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Xavier.GitHub maintained by <a href="https://github.com/a328940026">a328940026</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
